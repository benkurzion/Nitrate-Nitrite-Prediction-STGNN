import pandas as pd
import numpy as np
import datetime
from datetime import datetime
PATH_TO_NODE_FEATURES = "node_features.txt"
PATH_TO_ADJ_MAT = "adjmatrix.txt"


'''
40 training 40 validation 20 testing
batch of training data has sliding window. 
use all of the features - past 5 days and altidude and discharge. date doenst matter
split the data using percentages of seasons. (uniform sampling?)
only scale if we need to

search up for stgnn layers
stgcn? instead

'''

# Load the data
fullData = pd.read_csv(filepath_or_buffer=PATH_TO_NODE_FEATURES, sep=",")
adjMatrix = pd.read_csv(filepath_or_buffer=PATH_TO_ADJ_MAT, sep=",", header=None, index_col=None)


# Change dateTime column from strings to datetime object
fullData['dateTime'] = pd.to_datetime(fullData['dateTime'], format='%Y-%m-%d')

# removing rows which have measurements between '2021-04-01' and '2021-04-06' inclusive

fullData = fullData[(fullData['dateTime'] > '2021-04-06')]


# helper method that generates the ranges for each season
def get_season_range(df):
    date1_spr = '2021-04-01'
    date2_spr = '2021-05-31'

    # Convert the date strings to datetime objects
    sp_date1 = datetime.strptime(date1_spr, '%Y-%m-%d')
    sp_date2 = datetime.strptime(date2_spr, '%Y-%m-%d')


    season_range = []
    # Calculate the difference in days
    spring_days = (sp_date2 - sp_date1).days
    season_range.append(spring_days)

    date1_sum = '2021-06-01'
    date2_sum = '2021-08-31'

    sum_date1 = datetime.strptime(date1_sum, '%Y-%m-%d')
    sum_date2 = datetime.strptime(date2_sum, '%Y-%m-%d')

    season_range.append((sum_date2 - sum_date1).days)

    date1_fall = '2021-09-01'
    date2_fall = '2021-11-30'


    fall_date1 = datetime.strptime(date1_fall, '%Y-%m-%d')
    fall_date2 = datetime.strptime(date2_fall, '%Y-%m-%d')

    season_range.append((fall_date2 - fall_date1).days)

    date1_win = '2021-12-01'
    date2_win = '2022-02-28'

    win_date1 = datetime.strptime(date1_win, '%Y-%m-%d')
    win_date2 = datetime.strptime(date2_win, '%Y-%m-%d')

    season_range.append((win_date2 - win_date1).days)
    return season_range

range_arr = get_season_range(fullData)

# construct edge_index and edge_weight arrays
sourceNodes = []
sinkNodes = []
edge_weight = []
for i in range(0, adjMatrix.shape[0]):
    for j in range(0, adjMatrix.shape[1]):
        if adjMatrix.iat[i, j] != 0:
            sourceNodes.append(j)
            sinkNodes.append(i)
            edge_weight.append(adjMatrix.iat[i, j])

edge_index = np.array([sourceNodes, sinkNodes])
edge_weight = np.array(edge_weight)



# Following code constructs feature matrix for the latter 360 - daysPrior days using the previous daysPrior labels as features.
# Update: Added day number to the feature set new shape is (days, nodes, 8)

daysPrior = 5
features = np.zeros((360 - daysPrior, adjMatrix.shape[0],
                     daysPrior + 3))  # Time step, nodes, daysPrior previous "nitrite+nitrate" concentrations and water discharge and altitude
nodeNumber = -1
i = 0
print(fullData.iat[5, 2])
while i < (fullData.shape[0]):
    if i == 0 or fullData.iat[i, 1] != fullData.iat[i - 1, 1]:  # Begin data entry for next node
        nodeNumber += 1
        i = i + daysPrior

    dayIndex = (fullData.iat[i, 2] - fullData.iat[0, 2]).days - daysPrior
    print(dayIndex)
    # Fill in previous daysPrior "nitrite+nitrate" concentrations (scaled)
    for j in range(daysPrior):
        features[dayIndex][nodeNumber][j] = fullData.iat[i - j - 1, 4]
    features[dayIndex][nodeNumber][daysPrior] = fullData.iat[i, 3]  # water discharge feature (scaled)
    features[dayIndex][nodeNumber][daysPrior + 1] = fullData.iat[i, 7]
    features[dayIndex][nodeNumber][daysPrior+2] = dayIndex
    # altitude feature (scaled)
    i += 1



# partitioning features array based on season


spring_arr_1 = features[: range_arr[0], :, :]

sum_arr = features[range_arr[0]: range_arr[0]+range_arr[1], :, :]
fall_arr = features[range_arr[1]+range_arr[0]: range_arr[0]+range_arr[1]+range_arr[2], :, :]
win_arr = features[range_arr[0]+range_arr[1]+range_arr[2]: range_arr[0]+range_arr[1]+range_arr[2]+range_arr[3], :, :]

# extracting the spring data for the year 2022
spring_arr_2 = features[range_arr[0]+range_arr[1]+range_arr[2]+range_arr[3]: range_arr[0]+range_arr[1]+range_arr[2]+range_arr[3]+25, :, :]

# combining spring 2021 and spring 2022 to get final spring set
final_spring_arr = np.concatenate((spring_arr_1, spring_arr_2), axis= 0)

# Extracting training, test and validation set


# Define the percentage for each set
train_percent = 0.4
val_percent = 0.4
test_percent = 0.2


# Function to split a season array into train, test, and validation sets
def split_season(season_arr):
    num_days = season_arr.shape[0]
    train_size = int(num_days * train_percent)
    val_size = int(num_days* val_percent)
    test_size = num_days - (train_size+val_size)


    train_set = season_arr[:train_size]
    val_set = season_arr[train_size: train_size+val_size]
    test_set = season_arr[train_size+val_size:]


    return train_set, val_set, test_set

# Split each season array into train, test, and validation sets
spring_train, spring_val, spring_test = split_season(final_spring_arr)
summer_train, summer_val, summer_test = split_season(sum_arr)
fall_train, fall_val, fall_test = split_season(fall_arr)
winter_train, winter_val, winter_test = split_season(win_arr)

# Combine the train, test, and validation sets from all seasons
train_set = np.concatenate((spring_train, summer_train, fall_train, winter_train), axis=0)
test_set = np.concatenate((spring_test, summer_test, fall_test, winter_test), axis=0)
val_set = np.concatenate((spring_val, summer_val, fall_val, winter_val), axis=0)

print(train_set)
print(test_set)
print(val_set)

targets = np.zeros((360 - daysPrior, adjMatrix.shape[0]))  # Time step, nodes
nodeNumber = -1
i = 0
while i < (fullData.shape[0]):
    if i == 0 or fullData.iat[i, 1] != fullData.iat[i - 1, 1]:  # Begin data entry for next node
        nodeNumber += 1
        i = i + daysPrior
    dayIndex = (fullData.iat[i, 2] - fullData.iat[0, 2]).days - daysPrior
    targets[dayIndex][nodeNumber] = fullData.iat[i, 4]  # the "nitrite+nitrate" column (scaled) = label
    i += 1
